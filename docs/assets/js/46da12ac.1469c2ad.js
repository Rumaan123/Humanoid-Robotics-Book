"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[261],{2051(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=i(4848),s=i(8453);const o={sidebar_position:5},t="Python-Based Robot Control: Understanding rclpy",l={id:"module-1/python-control",title:"Python-Based Robot Control: Understanding rclpy",description:"Overview",source:"@site/docs/module-1/python-control.md",sourceDirName:"module-1",slug:"/module-1/python-control",permalink:"/Humanoid-Robotics-Book/docs/module-1/python-control",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Core Concepts: Nodes, Topics, Services, and Actions",permalink:"/Humanoid-Robotics-Book/docs/module-1/core-concepts"},next:{title:"Humanoid Robot Modeling with URDF: Unified Robot Description Format",permalink:"/Humanoid-Robotics-Book/docs/module-1/urdf-modeling"}},a={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to rclpy",id:"introduction-to-rclpy",level:2},{value:"What is rclpy?",id:"what-is-rclpy",level:3},{value:"Key Features of rclpy",id:"key-features-of-rclpy",level:3},{value:"Installation and Setup",id:"installation-and-setup",level:3},{value:"Creating Your First rclpy Node",id:"creating-your-first-rclpy-node",level:2},{value:"Basic Node Structure",id:"basic-node-structure",level:3},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Implementing Publishers and Subscribers",id:"implementing-publishers-and-subscribers",level:2},{value:"Creating a Publisher",id:"creating-a-publisher",level:3},{value:"Creating a Subscriber",id:"creating-a-subscriber",level:3},{value:"Working with Services",id:"working-with-services",level:2},{value:"Creating a Service Server",id:"creating-a-service-server",level:3},{value:"Creating a Service Client",id:"creating-a-service-client",level:3},{value:"Implementing Actions",id:"implementing-actions",level:2},{value:"Creating an Action Server",id:"creating-an-action-server",level:3},{value:"Advanced rclpy Concepts",id:"advanced-rclpy-concepts",level:2},{value:"Asynchronous Programming with rclpy",id:"asynchronous-programming-with-rclpy",level:3},{value:"Quality of Service (QoS) Configuration",id:"quality-of-service-qos-configuration",level:3},{value:"Practical Applications in Humanoid Robotics",id:"practical-applications-in-humanoid-robotics",level:2},{value:"Joint Control with rclpy",id:"joint-control-with-rclpy",level:3},{value:"Integration with AI Libraries",id:"integration-with-ai-libraries",level:3},{value:"Best Practices for rclpy Development",id:"best-practices-for-rclpy-development",level:2},{value:"Error Handling and Robustness",id:"error-handling-and-robustness",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Integration with Physical AI Systems",id:"integration-with-physical-ai-systems",level:2},{value:"Sensor Data Processing Pipeline",id:"sensor-data-processing-pipeline",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"python-based-robot-control-understanding-rclpy",children:"Python-Based Robot Control: Understanding rclpy"}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Robot Operating System 2 (ROS 2) Python client library, known as rclpy, provides Python developers with the ability to create ROS 2 nodes, publish and subscribe to topics, provide and use services, and work with actions. In the context of Physical AI and humanoid robotics, rclpy enables rapid prototyping and development of robotic applications using Python's accessible syntax and rich ecosystem of scientific computing libraries."}),"\n",(0,r.jsx)(n.p,{children:"Python-based robot control is particularly valuable in Physical AI applications where researchers and developers need to integrate machine learning models, perform data analysis, and create high-level behaviors without the complexity of lower-level languages. The rclpy library bridges the gap between Python's accessibility and ROS 2's powerful robotic middleware capabilities."}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this section, you should be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the fundamentals of rclpy and its role in ROS 2 Python development"}),"\n",(0,r.jsx)(n.li,{children:"Create ROS 2 nodes using Python and rclpy"}),"\n",(0,r.jsx)(n.li,{children:"Implement publishers, subscribers, services, and actions in Python"}),"\n",(0,r.jsx)(n.li,{children:"Design control loops and state management for humanoid robots using Python"}),"\n",(0,r.jsx)(n.li,{children:"Integrate Python-based AI algorithms with ROS 2 communication patterns"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-rclpy",children:"Introduction to rclpy"}),"\n",(0,r.jsx)(n.h3,{id:"what-is-rclpy",children:"What is rclpy?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"rclpy"})," is the Python client library for ROS 2 that provides Python bindings for the ROS 2 client library (rcl). It allows Python developers to interact with the ROS 2 ecosystem using familiar Python idioms while maintaining compatibility with other ROS 2 client libraries like rclcpp (C++)."]}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-rclpy",children:"Key Features of rclpy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pythonic API"}),": Designed to follow Python conventions and patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Support"}),": Built-in support for asyncio for non-blocking operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Type Support"}),": Full support for ROS 2 message types and services"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Lifecycle Management"}),": Proper initialization and cleanup of ROS 2 nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quality of Service (QoS) Support"}),": Configurable communication policies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Threading Support"}),": Safe multi-threaded access to ROS 2 operations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,r.jsx)(n.p,{children:"To use rclpy, you need to have ROS 2 installed on your system. The library is typically included with ROS 2 distributions:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Verify rclpy is available\npython3 -c \"import rclpy; print('rclpy version:', rclpy.__version__)\"\n"})}),"\n",(0,r.jsx)(n.h2,{id:"creating-your-first-rclpy-node",children:"Creating Your First rclpy Node"}),"\n",(0,r.jsx)(n.h3,{id:"basic-node-structure",children:"Basic Node Structure"}),"\n",(0,r.jsx)(n.p,{children:"A minimal rclpy node follows this structure:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MinimalNode(Node):\n    def __init__(self):\n        super().__init__('minimal_node')\n        self.get_logger().info('Minimal node has been started')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MinimalNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"The typical lifecycle of an rclpy node includes:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initialization"}),": Setting up the ROS 2 context with ",(0,r.jsx)(n.code,{children:"rclpy.init()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Creation"}),": Creating a Node instance with appropriate parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Entity Creation"}),": Setting up publishers, subscribers, services, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spinning"}),": Running the event loop with ",(0,r.jsx)(n.code,{children:"rclpy.spin()"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cleanup"}),": Properly destroying resources and shutting down"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementing-publishers-and-subscribers",children:"Implementing Publishers and Subscribers"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-publisher",children:"Creating a Publisher"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-subscriber",children:"Creating a Subscriber"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"working-with-services",children:"Working with Services"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-service-server",children:"Creating a Service Server"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request\\na: {request.a}, b: {request.b}\\n')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-service-client",children:"Creating a Service Client"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClient(Node):\n    def __init__(self):\n        super().__init__('minimal_client')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClient()\n    response = minimal_client.send_request(1, 2)\n    minimal_client.get_logger().info(f'Result of add_two_ints: {response.sum}')\n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementing-actions",children:"Implementing Actions"}),"\n",(0,r.jsx)(n.h3,{id:"creating-an-action-server",children:"Creating an Action Server"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, CancelResponse, GoalResponse\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\n\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            execute_callback=self.execute_callback,\n            callback_group=ReentrantCallbackGroup(),\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n\n    def destroy(self):\n        self._action_server.destroy()\n        super().destroy_node()\n\n    def goal_callback(self, goal_request):\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n\n            self.get_logger().info(f'Publishing feedback: {feedback_msg.sequence}')\n            goal_handle.publish_feedback(feedback_msg)\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        self.get_logger().info(f'Returning result: {result.sequence}')\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_server = FibonacciActionServer()\n    executor = MultiThreadedExecutor()\n    rclpy.spin(action_server, executor=executor)\n    action_server.destroy()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-rclpy-concepts",children:"Advanced rclpy Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"asynchronous-programming-with-rclpy",children:"Asynchronous Programming with rclpy"}),"\n",(0,r.jsx)(n.p,{children:"rclpy supports Python's asyncio for non-blocking operations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile\nfrom std_msgs.msg import String\nimport asyncio\n\nclass AsyncNode(Node):\n    def __init__(self):\n        super().__init__('async_node')\n        self.publisher = self.create_publisher(String, 'async_topic', QoSProfile(depth=10))\n\n    async def async_publish(self, message):\n        msg = String()\n        msg.data = message\n        self.publisher.publish(msg)\n        await asyncio.sleep(0.1)  # Non-blocking sleep\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = AsyncNode()\n\n    async def run_publisher():\n        for i in range(10):\n            await node.async_publish(f'Async message {i}')\n\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"quality-of-service-qos-configuration",children:"Quality of Service (QoS) Configuration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\n\n# Example QoS configuration for different use cases\n# For sensor data (high frequency, best-effort)\nsensor_qos = QoSProfile(\n    depth=10,\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    durability=DurabilityPolicy.VOLATILE\n)\n\n# For critical control commands (reliable, durable)\ncontrol_qos = QoSProfile(\n    depth=1,\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.TRANSIENT_LOCAL\n)\n\n# Usage in publisher/subscriber\npublisher = self.create_publisher(String, 'topic', sensor_qos)\nsubscriber = self.create_subscription(String, 'topic', callback, control_qos)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"practical-applications-in-humanoid-robotics",children:"Practical Applications in Humanoid Robotics"}),"\n",(0,r.jsx)(n.h3,{id:"joint-control-with-rclpy",children:"Joint Control with rclpy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.msg import JointTrajectoryControllerState\n\nclass JointController(Node):\n    def __init__(self):\n        super().__init__(\'joint_controller\')\n\n        # Publishers for joint commands\n        self.joint_cmd_pub = self.create_publisher(\n            JointTrajectory,\n            \'/joint_trajectory_controller/joint_trajectory\',\n            10\n        )\n\n        # Subscribers for joint feedback\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100Hz\n\n        self.current_joint_positions = {}\n        self.target_positions = {}\n\n    def joint_state_callback(self, msg):\n        """Update current joint positions"""\n        for i, name in enumerate(msg.name):\n            self.current_joint_positions[name] = msg.position[i]\n\n    def control_loop(self):\n        """Main control loop for humanoid robot joints"""\n        # Calculate desired joint positions based on control logic\n        trajectory_msg = JointTrajectory()\n        trajectory_msg.joint_names = list(self.current_joint_positions.keys())\n\n        point = JointTrajectoryPoint()\n        # Set target positions and velocities\n        point.positions = [self.target_positions.get(name, 0.0)\n                          for name in trajectory_msg.joint_names]\n        point.velocities = [0.0] * len(trajectory_msg.joint_names)\n        point.time_from_start.sec = 0\n        point.time_from_start.nanosec = 10000000  # 10ms\n\n        trajectory_msg.points = [point]\n        self.joint_cmd_pub.publish(trajectory_msg)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"integration-with-ai-libraries",children:"Integration with AI Libraries"}),"\n",(0,r.jsx)(n.p,{children:"rclpy seamlessly integrates with Python's rich ecosystem of AI and machine learning libraries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nimport numpy as np\nimport tensorflow as tf  # Example with TensorFlow\nfrom sensor_msgs.msg import Image\nfrom cv_bridge import CvBridge\nimport cv2\n\nclass AIPerceptionNode(Node):\n    def __init__(self):\n        super().__init__('ai_perception_node')\n        self.cv_bridge = CvBridge()\n\n        # Load pre-trained model\n        self.model = tf.keras.models.load_model('/path/to/model')\n\n        # Subscribe to camera feed\n        self.image_sub = self.create_subscription(\n            Image,\n            '/camera/image_raw',\n            self.image_callback,\n            10\n        )\n\n        # Publisher for detection results\n        self.detection_pub = self.create_publisher(String, '/detections', 10)\n\n    def image_callback(self, msg):\n        \"\"\"Process image with AI model\"\"\"\n        try:\n            # Convert ROS image to OpenCV format\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, \"bgr8\")\n\n            # Preprocess image for model\n            input_tensor = np.expand_dims(cv_image, axis=0)\n            input_tensor = tf.cast(input_tensor, tf.float32) / 255.0\n\n            # Run inference\n            predictions = self.model.predict(input_tensor)\n\n            # Process results and publish\n            result_msg = String()\n            result_msg.data = f'Detections: {predictions}'\n            self.detection_pub.publish(result_msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Error in image processing: {e}')\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices-for-rclpy-development",children:"Best Practices for rclpy Development"}),"\n",(0,r.jsx)(n.h3,{id:"error-handling-and-robustness",children:"Error Handling and Robustness"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.exceptions import ParameterNotDeclaredException\n\nclass RobustNode(Node):\n    def __init__(self):\n        super().__init__('robust_node')\n\n        # Proper parameter handling\n        self.declare_parameter('control_frequency', 100)\n        self.control_frequency = self.get_parameter('control_frequency').value\n\n        # Try-catch for resource creation\n        try:\n            self.publisher = self.create_publisher(String, 'topic', 10)\n        except Exception as e:\n            self.get_logger().error(f'Failed to create publisher: {e}')\n            raise\n\n    def safe_publish(self, msg):\n        \"\"\"Safely publish message with error handling\"\"\"\n        try:\n            if self.publisher.get_subscription_count() > 0:\n                self.publisher.publish(msg)\n        except Exception as e:\n            self.get_logger().error(f'Publish failed: {e}')\n"})}),"\n",(0,r.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate QoS settings"})," for different data types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize message copying"})," by using efficient data structures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider threading"})," for CPU-intensive operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate timer rates"})," for control loops"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper cleanup"})," to prevent resource leaks"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-physical-ai-systems",children:"Integration with Physical AI Systems"}),"\n",(0,r.jsx)(n.h3,{id:"sensor-data-processing-pipeline",children:"Sensor Data Processing Pipeline"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu, JointState\nfrom geometry_msgs.msg import Twist\nimport numpy as np\n\nclass SensorProcessingNode(Node):\n    def __init__(self):\n        super().__init__('sensor_processing_node')\n\n        # Subscribe to various sensors\n        self.imu_sub = self.create_subscription(Imu, '/imu/data', self.imu_callback, 10)\n        self.joint_sub = self.create_subscription(JointState, '/joint_states', self.joint_callback, 10)\n        self.cmd_sub = self.create_subscription(Twist, '/cmd_vel', self.cmd_callback, 10)\n\n        # Publisher for processed data\n        self.state_pub = self.create_publisher(String, '/robot_state', 10)\n\n        self.robot_state = {\n            'imu_orientation': np.array([0.0, 0.0, 0.0, 1.0]),\n            'joint_positions': {},\n            'desired_velocity': np.array([0.0, 0.0, 0.0])\n        }\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for balance and orientation\"\"\"\n        self.robot_state['imu_orientation'] = np.array([\n            msg.orientation.x,\n            msg.orientation.y,\n            msg.orientation.z,\n            msg.orientation.w\n        ])\n\n    def joint_callback(self, msg):\n        \"\"\"Update joint state information\"\"\"\n        for i, name in enumerate(msg.name):\n            if i < len(msg.position):\n                self.robot_state['joint_positions'][name] = msg.position[i]\n\n    def cmd_callback(self, msg):\n        \"\"\"Update desired velocity commands\"\"\"\n        self.robot_state['desired_velocity'] = np.array([\n            msg.linear.x,\n            msg.linear.y,\n            msg.angular.z\n        ])\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"rclpy provides a powerful and Pythonic way to develop robotic applications within the ROS 2 ecosystem. Its integration with Python's scientific computing libraries makes it particularly valuable for Physical AI applications where machine learning, computer vision, and data analysis are essential components. Understanding rclpy fundamentals enables developers to create sophisticated humanoid robot control systems that can seamlessly integrate perception, cognition, and action components."}),"\n",(0,r.jsx)(n.p,{children:"The asynchronous capabilities, Quality of Service configuration, and robust node lifecycle management make rclpy suitable for both rapid prototyping and production robotic systems. When combined with ROS 2's distributed architecture, rclpy enables the development of complex Physical AI systems that can operate reliably in real-world environments."}),"\n",(0,r.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["ROS 2 Documentation: ",(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/",children:"https://docs.ros.org/en/humble/"})]}),"\n",(0,r.jsxs)(n.li,{children:["rclpy API Documentation: ",(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/p/rclpy/",children:"https://docs.ros.org/en/humble/p/rclpy/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Python ROS 2 Tutorials: ",(0,r.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials.html",children:"https://docs.ros.org/en/humble/Tutorials.html"})]}),"\n",(0,r.jsx)(n.li,{children:"Control Systems in Robotics: Modern Robotics by Lynch and Park"}),"\n",(0,r.jsx)(n.li,{children:"Probabilistic Robotics by Thrun, Burgard, and Fox"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>t,x:()=>l});var r=i(6540);const s={},o=r.createContext(s);function t(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);