"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[599],{5310(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var o=i(4848),t=i(8453);const s={sidebar_position:5},a="Environment and Robot Simulation using Gazebo: Physics-Based Digital Twins",r={id:"module-2/gazebo-simulation",title:"Environment and Robot Simulation using Gazebo: Physics-Based Digital Twins",description:"Overview",source:"@site/docs/module-2/gazebo-simulation.md",sourceDirName:"module-2",slug:"/module-2/gazebo-simulation",permalink:"/Humanoid-Robotics-Book/docs/module-2/gazebo-simulation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Physics Simulation Concepts: Rigid Body Dynamics and Collision Handling",permalink:"/Humanoid-Robotics-Book/docs/module-2/physics-simulation"},next:{title:"Sensor Simulation: LiDAR, Depth Cameras, and IMUs for Physical AI Systems",permalink:"/Humanoid-Robotics-Book/docs/module-2/sensor-simulation"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"What is Gazebo?",id:"what-is-gazebo",level:3},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"Setting Up Gazebo with ROS 2",id:"setting-up-gazebo-with-ros-2",level:2},{value:"Installation and Configuration",id:"installation-and-configuration",level:3},{value:"Basic Gazebo Launch",id:"basic-gazebo-launch",level:3},{value:"Robot Modeling for Gazebo",id:"robot-modeling-for-gazebo",level:2},{value:"URDF to SDF Conversion",id:"urdf-to-sdf-conversion",level:3},{value:"Gazebo-Specific Robot Description",id:"gazebo-specific-robot-description",level:3},{value:"Environment Design in Gazebo",id:"environment-design-in-gazebo",level:2},{value:"Creating World Files",id:"creating-world-files",level:3},{value:"Custom Environment Models",id:"custom-environment-models",level:3},{value:"Sensor Integration in Gazebo",id:"sensor-integration-in-gazebo",level:2},{value:"Camera Sensors",id:"camera-sensors",level:3},{value:"LiDAR Sensors",id:"lidar-sensors",level:3},{value:"IMU Sensors",id:"imu-sensors",level:3},{value:"Control Integration with ROS 2",id:"control-integration-with-ros-2",level:2},{value:"Joint Control Plugins",id:"joint-control-plugins",level:3},{value:"Custom Control Plugins",id:"custom-control-plugins",level:3},{value:"Gazebo Simulation Best Practices",id:"gazebo-simulation-best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Physics Parameter Tuning",id:"physics-parameter-tuning",level:3},{value:"Advanced Gazebo Features",id:"advanced-gazebo-features",level:2},{value:"Dynamic Environments",id:"dynamic-environments",level:3},{value:"Multi-Robot Simulation",id:"multi-robot-simulation",level:3},{value:"Custom Plugins for Specialized Behavior",id:"custom-plugins-for-specialized-behavior",level:3},{value:"Integration with ROS 2 Ecosystem",id:"integration-with-ros-2-ecosystem",level:2},{value:"Launch Files for Complete Simulation",id:"launch-files-for-complete-simulation",level:3},{value:"Simulation Testing Framework",id:"simulation-testing-framework",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Physics Issues",id:"physics-issues",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"environment-and-robot-simulation-using-gazebo-physics-based-digital-twins",children:"Environment and Robot Simulation using Gazebo: Physics-Based Digital Twins"}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo stands as one of the most widely adopted physics-based simulation environments in robotics, providing realistic simulation capabilities for both robots and their environments. In the context of Physical AI and humanoid robotics, Gazebo enables the creation of sophisticated digital twins that accurately model robot kinematics, dynamics, sensor systems, and environmental interactions. This simulation environment serves as a critical bridge between theoretical AI models and embodied physical systems, allowing for safe, cost-effective development and testing of complex robotic behaviors."}),"\n",(0,o.jsx)(e.p,{children:"Gazebo's integration with ROS 2 through Gazebo ROS 2 packages enables seamless workflows where simulation models can be developed, tested, and validated before deployment on physical robots. The platform's robust physics engine, diverse sensor models, and flexible environment creation tools make it particularly suitable for humanoid robotics applications where safety, complexity, and multi-modal interaction are paramount."}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this section, you should be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Create realistic robot models for simulation in Gazebo"}),"\n",(0,o.jsx)(e.li,{children:"Design complex environments with appropriate physics properties"}),"\n",(0,o.jsx)(e.li,{children:"Configure sensors and actuators for simulation"}),"\n",(0,o.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for seamless simulation workflows"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,o.jsx)(e.h3,{id:"what-is-gazebo",children:"What is Gazebo?"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Gazebo"})," is a physics-based simulation environment that provides realistic simulation of robots and their environments. Originally developed by the Open Source Robotics Foundation (OSRF), Gazebo has become the de facto standard for robotics simulation, offering:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"High-fidelity physics simulation"})," using ODE, Bullet, or DART physics engines"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Realistic sensor simulation"})," including cameras, LiDAR, IMUs, and force/torque sensors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Flexible environment modeling"})," with support for complex scenes and dynamic objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ROS integration"})," for seamless communication with robotic applications"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Plugin architecture"})," for extending functionality"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo follows a client-server architecture:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-mermaid",children:"graph TB\n    A[GUI Client] --\x3e B[Gazebo Server]\n    C[ROS 2 Nodes] --\x3e D[Gazebo ROS 2 Bridge]\n    D --\x3e B\n    B --\x3e E[Physics Engine]\n    B --\x3e F[Sensor Engine]\n    B --\x3e G[Rendering Engine]\n"})}),"\n",(0,o.jsx)(e.p,{children:"The architecture consists of:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gazebo Server"}),": Core simulation engine handling physics, sensors, and rendering"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GUI Client"}),": Visualization and interaction interface"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gazebo ROS 2 Bridge"}),": Communication layer between Gazebo and ROS 2"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Physics Engine"}),": ODE, Bullet, or DART for physics simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensor Engine"}),": Realistic sensor simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Rendering Engine"}),": 3D visualization and graphics"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"setting-up-gazebo-with-ros-2",children:"Setting Up Gazebo with ROS 2"}),"\n",(0,o.jsx)(e.h3,{id:"installation-and-configuration",children:"Installation and Configuration"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo integration with ROS 2 requires specific packages:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo with ROS 2 support\nsudo apt install ros-humble-gazebo-ros-pkgs\nsudo apt install ros-humble-gazebo-ros2-control\nsudo apt install ros-humble-gazebo-dev\n\n# Verify installation\ngz --version\n"})}),"\n",(0,o.jsx)(e.h3,{id:"basic-gazebo-launch",children:"Basic Gazebo Launch"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# launch/gazebo_simulation.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Declare launch arguments\n    world_arg = DeclareLaunchArgument(\n        'world',\n        default_value='empty.sdf',\n        description='Choose one of the world files from `/gazebo_worlds`'\n    )\n\n    # Launch Gazebo server\n    gzserver = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gzserver.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': LaunchConfiguration('world'),\n            'verbose': 'false'\n        }.items()\n    )\n\n    # Launch Gazebo client\n    gzclient = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gzclient.launch.py'\n            ])\n        ])\n    )\n\n    return LaunchDescription([\n        world_arg,\n        gzserver,\n        gzclient\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"robot-modeling-for-gazebo",children:"Robot Modeling for Gazebo"}),"\n",(0,o.jsx)(e.h3,{id:"urdf-to-sdf-conversion",children:"URDF to SDF Conversion"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo primarily uses SDF (Simulation Description Format), but can work with URDF:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example: Adding Gazebo-specific elements to URDF --\x3e\n<robot name="humanoid_robot">\n  \x3c!-- Standard URDF content --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\n      <inertia ixx="1.0" ixy="0" ixz="0" iyy="1.0" iyz="0" izz="1.0"/>\n    </inertial>\n    <visual>\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 1.0"/>\n      </geometry>\n      <material name="gray">\n        <color rgba="0.5 0.5 0.5 1"/>\n      </material>\n    </visual>\n    <collision>\n      <origin xyz="0 0 0.5" rpy="0 0 0"/>\n      <geometry>\n        <box size="0.3 0.3 1.0"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Gazebo-specific elements --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Gray</material>\n    <mu1>0.2</mu1>\n    <mu2>0.2</mu2>\n    <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n    <kd>1.0</kd>        \x3c!-- Contact damping --\x3e\n  </gazebo>\n\n  \x3c!-- Joint with actuator --\x3e\n  <joint name="hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_leg"/>\n    <origin xyz="0 -0.1 0" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="200" velocity="2"/>\n  </joint>\n\n  \x3c!-- Gazebo plugin for joint control --\x3e\n  <gazebo>\n    <plugin filename="libgazebo_ros_joint_trajectory.so" name="joint_trajectory">\n      <commandTopic>joint_trajectory</commandTopic>\n      <stateTopic>joint_trajectory_states</stateTopic>\n      <actionTopic>joint_trajectory_action</actionTopic>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"gazebo-specific-robot-description",children:"Gazebo-Specific Robot Description"}),"\n",(0,o.jsx)(e.p,{children:"For more advanced features, use SDF directly:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.7">\n  <model name="humanoid_robot">\n    \x3c!-- Model properties --\x3e\n    <static>false</static>\n    <self_collide>false</self_collide>\n\n    \x3c!-- Links --\x3e\n    <link name="base_link">\n      <pose>0 0 1 0 0 0</pose>\n      <inertial>\n        <mass>10.0</mass>\n        <inertia>\n          <ixx>1.0</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>1.0</iyy>\n          <iyz>0.0</iyz>\n          <izz>1.0</izz>\n        </inertia>\n      </inertial>\n\n      \x3c!-- Visual --\x3e\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.3 0.3 1.0</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.5 1</ambient>\n          <diffuse>0.5 0.5 0.5 1</diffuse>\n          <specular>0.1 0.1 0.1 1</specular>\n        </material>\n      </visual>\n\n      \x3c!-- Collision --\x3e\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.3 0.3 1.0</size>\n          </box>\n        </geometry>\n        <surface>\n          <friction>\n            <ode>\n              <mu>0.2</mu>\n              <mu2>0.2</mu2>\n            </ode>\n          </friction>\n          <contact>\n            <ode>\n              <kp>1000000.0</kp>\n              <kd>1.0</kd>\n            </ode>\n          </contact>\n        </surface>\n      </collision>\n    </link>\n\n    \x3c!-- Joint --\x3e\n    <joint name="hip_joint" type="revolute">\n      <parent>base_link</parent>\n      <child>left_leg</child>\n      <pose>0 -0.1 0 0 0 0</pose>\n      <axis>\n        <xyz>0 0 1</xyz>\n        <limit>\n          <lower>-1.57</lower>\n          <upper>1.57</upper>\n          <effort>200</effort>\n          <velocity>2</velocity>\n        </limit>\n      </axis>\n    </joint>\n  </model>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"environment-design-in-gazebo",children:"Environment Design in Gazebo"}),"\n",(0,o.jsx)(e.h3,{id:"creating-world-files",children:"Creating World Files"}),"\n",(0,o.jsx)(e.p,{children:"World files define the simulation environment:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.7">\n  <world name="humanoid_world">\n    \x3c!-- Physics engine configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- GUI configuration --\x3e\n    <gui fullscreen="0">\n      <camera name="user_camera">\n        <pose>-5 -5 3 0 0.4 1.5708</pose>\n        <view_controller>orbit</view_controller>\n        <projection_type>perspective</projection_type>\n      </camera>\n    </gui>\n\n    \x3c!-- Light sources --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <attenuation>\n        <range>1000</range>\n        <constant>0.9</constant>\n        <linear>0.01</linear>\n        <quadratic>0.001</quadratic>\n      </attenuation>\n      <direction>-0.3 0.3 -1</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- Sky --\x3e\n    <include>\n      <uri>model://sky</uri>\n    </include>\n\n    \x3c!-- Robot model --\x3e\n    <include>\n      <uri>model://humanoid_robot</uri>\n      <pose>0 0 1.0 0 0 0</pose>\n    </include>\n\n    \x3c!-- Environment objects --\x3e\n    <model name="table">\n      <pose>2 0 0 0 0 0</pose>\n      <link name="table_base">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1.0 0.8 0.8</size>\n            </box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1.0 0.8 0.8</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.6 0.2 1</ambient>\n            <diffuse>0.8 0.6 0.2 1</diffuse>\n          </material>\n        </visual>\n        <inertial>\n          <mass>50.0</mass>\n          <inertia>\n            <ixx>1.0</ixx>\n            <ixy>0.0</ixy>\n            <ixz>0.0</ixz>\n            <iyy>1.0</iyy>\n            <iyz>0.0</iyz>\n            <izz>1.0</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n    \x3c!-- Obstacles --\x3e\n    <model name="obstacle_1">\n      <pose>1 1 0.5 0 0 0</pose>\n      <static>true</static>\n      <link name="obstacle_link">\n        <collision name="collision">\n          <geometry>\n            <cylinder>\n              <radius>0.2</radius>\n              <length>1.0</length>\n            </cylinder>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <cylinder>\n              <radius>0.2</radius>\n              <length>1.0</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0.2 0.2 0.8 1</ambient>\n            <diffuse>0.2 0.2 0.8 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"custom-environment-models",children:"Custom Environment Models"}),"\n",(0,o.jsx)(e.p,{children:"Creating custom environment models:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- ~/.gazebo/models/my_room/model.sdf --\x3e\n<?xml version="1.0" ?>\n<sdf version="1.7">\n  <model name="my_room">\n    <static>true</static>\n\n    \x3c!-- Room walls --\x3e\n    <link name="wall_front">\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>10 0.2 3</size>\n          </box>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>10 0.2 3</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.8 0.8 0.8 1</ambient>\n          <diffuse>0.8 0.8 0.8 1</diffuse>\n        </material>\n      </visual>\n    </link>\n\n    <link name="wall_back">\n      <pose>0 5 1.5 0 0 0</pose>\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>10 0.2 3</size>\n          </box>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>10 0.2 3</size>\n          </box>\n        </geometry>\n        <material>\n          <ambient>0.8 0.8 0.8 1</ambient>\n          <diffuse>0.8 0.8 0.8 1</diffuse>\n        </material>\n      </visual>\n    </link>\n\n    \x3c!-- Furniture --\x3e\n    <include>\n      <uri>model://table</uri>\n      <pose>2 2 0 0 0 0</pose>\n    </include>\n\n    <include>\n      <uri>model://chair</uri>\n      <pose>2.5 2.5 0 0 0 1.57</pose>\n    </include>\n  </model>\n</sdf>\n\n\x3c!-- ~/.gazebo/models/my_room/model.config --\x3e\n<?xml version="1.0"?>\n<model>\n  <name>my_room</name>\n  <version>1.0</version>\n  <sdf version="1.7">model.sdf</sdf>\n  <author>\n    <name>Your Name</name>\n    <email>your.email@example.com</email>\n  </author>\n  <description>\n    A custom room environment for humanoid robot simulation.\n  </description>\n</model>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"sensor-integration-in-gazebo",children:"Sensor Integration in Gazebo"}),"\n",(0,o.jsx)(e.h3,{id:"camera-sensors",children:"Camera Sensors"}),"\n",(0,o.jsx)(e.p,{children:"Configuring camera sensors for perception:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="camera_link">\n  <sensor name="camera" type="camera">\n    <always_on>true</always_on>\n    <update_rate>30</update_rate>\n    <camera>\n      <horizontal_fov>1.047</horizontal_fov> \x3c!-- 60 degrees --\x3e\n      <image>\n        <width>640</width>\n        <height>480</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>10.0</far>\n      </clip>\n      <noise>\n        <type>gaussian</type>\n        <mean>0.0</mean>\n        <stddev>0.007</stddev>\n      </noise>\n    </camera>\n    <visualize>true</visualize>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"lidar-sensors",children:"LiDAR Sensors"}),"\n",(0,o.jsx)(e.p,{children:"Configuring LiDAR for 3D perception:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="lidar_link">\n  <sensor name="lidar" type="ray">\n    <always_on>true</always_on>\n    <update_rate>10</update_rate>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>720</samples>\n          <resolution>1</resolution>\n          <min_angle>-1.570796</min_angle> \x3c!-- -90 degrees --\x3e\n          <max_angle>1.570796</max_angle>   \x3c!-- 90 degrees --\x3e\n        </horizontal>\n        <vertical>\n          <samples>1</samples>\n          <resolution>1</resolution>\n          <min_angle>0</min_angle>\n          <max_angle>0</max_angle>\n        </vertical>\n      </scan>\n      <range>\n        <min>0.1</min>\n        <max>30.0</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\n      <ros>\n        <namespace>/laser</namespace>\n        <remapping>~/out:=scan</remapping>\n      </ros>\n      <output_type>sensor_msgs/LaserScan</output_type>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"imu-sensors",children:"IMU Sensors"}),"\n",(0,o.jsx)(e.p,{children:"Configuring IMU for orientation and acceleration:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="imu_link">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <imu>\n      <angular_velocity>\n        <x>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>2e-4</stddev>\n            <bias_mean>0.0000075</bias_mean>\n            <bias_stddev>0.0000008</bias_stddev>\n          </noise>\n        </x>\n        <y>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>2e-4</stddev>\n            <bias_mean>0.0000075</bias_mean>\n            <bias_stddev>0.0000008</bias_stddev>\n          </noise>\n        </y>\n        <z>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>2e-4</stddev>\n            <bias_mean>0.0000075</bias_mean>\n            <bias_stddev>0.0000008</bias_stddev>\n          </noise>\n        </z>\n      </angular_velocity>\n      <linear_acceleration>\n        <x>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>1.7e-2</stddev>\n            <bias_mean>0.017</bias_mean>\n            <bias_stddev>0.0017</bias_stddev>\n          </noise>\n        </x>\n        <y>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>1.7e-2</stddev>\n            <bias_mean>0.017</bias_mean>\n            <bias_stddev>0.0017</bias_stddev>\n          </noise>\n        </y>\n        <z>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>1.7e-2</stddev>\n            <bias_mean>0.017</bias_mean>\n            <bias_stddev>0.0017</bias_stddev>\n          </noise>\n        </z>\n      </linear_acceleration>\n    </imu>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"control-integration-with-ros-2",children:"Control Integration with ROS 2"}),"\n",(0,o.jsx)(e.h3,{id:"joint-control-plugins",children:"Joint Control Plugins"}),"\n",(0,o.jsx)(e.p,{children:"Integrating joint control with ROS 2:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Using ros2_control for joint control --\x3e\n<gazebo>\n  <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">\n    <parameters>$(find my_robot_description)/config/robot_control.yaml</parameters>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# config/robot_control.yaml\ncontroller_manager:\n  ros__parameters:\n    update_rate: 1000  # Hz\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    # Position controllers\n    left_hip_position_controller:\n      type: position_controllers/JointGroupPositionController\n\n    right_hip_position_controller:\n      type: position_controllers/JointGroupPositionController\n\n    # Effort controllers for more dynamic control\n    torso_effort_controller:\n      type: effort_controllers/JointGroupEffortController\n\n# Joint group definitions\nleft_hip_position_controller:\n  ros__parameters:\n    joints:\n      - left_hip_yaw\n      - left_hip_pitch\n      - left_hip_roll\n\nright_hip_position_controller:\n  ros__parameters:\n    joints:\n      - right_hip_yaw\n      - right_hip_pitch\n      - right_hip_roll\n"})}),"\n",(0,o.jsx)(e.h3,{id:"custom-control-plugins",children:"Custom Control Plugins"}),"\n",(0,o.jsx)(e.p,{children:"Creating custom control plugins for specialized behavior:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"// include/my_robot_gazebo/CustomControllerPlugin.hpp\n#ifndef CUSTOM_CONTROLLER_PLUGIN_HPP\n#define CUSTOM_CONTROLLER_PLUGIN_HPP\n\n#include <gazebo/common/Plugin.hh>\n#include <gazebo/physics/physics.hh>\n#include <rclcpp/rclcpp.hpp>\n#include <std_msgs/msg/float64_multi_array.hpp>\n#include <sensor_msgs/msg/joint_state.hpp>\n\nnamespace gazebo\n{\nclass CustomControllerPlugin : public ModelPlugin\n{\npublic:\n    void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf) override;\n    void OnUpdate();\n\nprivate:\n    physics::ModelPtr model;\n    physics::PhysicsEnginePtr physics;\n    event::ConnectionPtr update_connection;\n\n    // ROS 2 components\n    rclcpp::Node::SharedPtr node;\n    rclcpp::Subscription<std_msgs::msg::Float64MultiArray>::SharedPtr command_sub;\n    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr state_pub;\n\n    std::vector<physics::JointPtr> joints;\n    std::vector<double> joint_positions;\n    std::vector<double> joint_velocities;\n    std::vector<double> joint_efforts;\n    std::vector<double> target_positions;\n\n    void CommandCallback(const std_msgs::msg::Float64MultiArray::SharedPtr msg);\n    void PublishState();\n};\n}\n\n#endif\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'// src/CustomControllerPlugin.cpp\n#include "my_robot_gazebo/CustomControllerPlugin.hpp"\n\nnamespace gazebo\n{\nvoid CustomControllerPlugin::Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\n{\n    model = _model;\n    physics = model->GetWorld()->Physics();\n\n    // Initialize ROS 2\n    if (!rclcpp::ok()) {\n        rclcpp::init(0, nullptr);\n    }\n\n    // Create node\n    node = rclcpp::Node::make_shared("gazebo_custom_controller");\n\n    // Subscribe to commands\n    command_sub = node->create_subscription<std_msgs::msg::Float64MultiArray>(\n        "/joint_commands", 10,\n        std::bind(&CustomControllerPlugin::CommandCallback, this, std::placeholders::_1)\n    );\n\n    // Publish joint states\n    state_pub = node->create_publisher<sensor_msgs::msg::JointState>(\n        "/joint_states", 10\n    );\n\n    // Get joints from model\n    for (const auto& joint_name : {"joint1", "joint2", "joint3"}) {\n        auto joint = model->GetJoint(joint_name);\n        if (joint) {\n            joints.push_back(joint);\n            joint_positions.push_back(0.0);\n            joint_velocities.push_back(0.0);\n            joint_efforts.push_back(0.0);\n            target_positions.push_back(0.0);\n        }\n    }\n\n    // Connect to Gazebo update event\n    update_connection = event::Events::ConnectWorldUpdateBegin(\n        std::bind(&CustomControllerPlugin::OnUpdate, this)\n    );\n}\n\nvoid CustomControllerPlugin::OnUpdate()\n{\n    // Update joint states\n    for (size_t i = 0; i < joints.size(); ++i) {\n        joint_positions[i] = joints[i]->Position(0);\n        joint_velocities[i] = joints[i]->GetVelocity(0);\n        joint_efforts[i] = joints[i]->GetForce(0);\n\n        // Apply control law (simple PD controller example)\n        double error = target_positions[i] - joint_positions[i];\n        double vel_error = 0.0 - joint_velocities[i];\n\n        double kp = 100.0;\n        double kd = 10.0;\n\n        double effort = kp * error + kd * vel_error;\n        joints[i]->SetForce(0, effort);\n    }\n\n    // Publish state\n    PublishState();\n\n    // Spin ROS 2 node\n    rclcpp::spin_some(node);\n}\n\nvoid CustomControllerPlugin::CommandCallback(const std_msgs::msg::Float64MultiArray::SharedPtr msg)\n{\n    if (msg->data.size() == target_positions.size()) {\n        for (size_t i = 0; i < msg->data.size(); ++i) {\n            target_positions[i] = msg->data[i];\n        }\n    }\n}\n\nvoid CustomControllerPlugin::PublishState()\n{\n    auto msg = sensor_msgs::msg::JointState();\n    msg.header.stamp = node->now();\n    msg.name.resize(joints.size());\n    msg.position.resize(joints.size());\n    msg.velocity.resize(joints.size());\n    msg.effort.resize(joints.size());\n\n    for (size_t i = 0; i < joints.size(); ++i) {\n        msg.name[i] = joints[i]->GetName();\n        msg.position[i] = joint_positions[i];\n        msg.velocity[i] = joint_velocities[i];\n        msg.effort[i] = joint_efforts[i];\n    }\n\n    state_pub->publish(msg);\n}\n}\n\nGZ_REGISTER_MODEL_PLUGIN(gazebo::CustomControllerPlugin)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"gazebo-simulation-best-practices",children:"Gazebo Simulation Best Practices"}),"\n",(0,o.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Performance monitoring and optimization\nclass GazeboPerformanceMonitor:\n    def __init__(self):\n        self.simulation_rate = 1000  # Hz\n        self.real_time_factor = 1.0\n        self.update_times = []\n        self.cpu_usage = []\n\n    def monitor_performance(self):\n        """Monitor and optimize Gazebo performance"""\n        # Check simulation rate\n        actual_rate = self.measure_simulation_rate()\n\n        if actual_rate < 0.8 * self.simulation_rate:\n            # Reduce physics complexity\n            self.reduce_physics_complexity()\n\n        # Monitor real-time factor\n        if self.real_time_factor < 0.9:\n            # Adjust time step\n            self.adjust_time_step()\n\n        # Monitor CPU usage\n        if self.get_cpu_usage() > 80:\n            # Reduce update rates\n            self.reduce_update_rates()\n\n    def reduce_physics_complexity(self):\n        """Reduce physics simulation complexity"""\n        # Simplify collision meshes\n        # Reduce solver iterations\n        # Use simpler contact models\n\n    def adjust_time_step(self):\n        """Adjust simulation time step"""\n        # Increase time step for better performance\n        # Decrease time step for better accuracy\n        pass\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-parameter-tuning",children:"Physics Parameter Tuning"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class PhysicsParameterTuner:\n    def __init__(self):\n        self.default_params = {\n            'time_step': 0.001,\n            'max_step_size': 0.001,\n            'real_time_factor': 1.0,\n            'solver_type': 'ode',\n            'solver_iterations': 100,\n            'solver_sor': 1.0,\n            'contact_surface_layer': 0.001,\n            'contact_max_correcting_vel': 100.0\n        }\n\n    def tune_for_robot(self, robot_model):\n        \"\"\"Tune physics parameters for specific robot\"\"\"\n        # Analyze robot characteristics\n        mass_distribution = self.analyze_mass_distribution(robot_model)\n        joint_constraints = self.analyze_joint_constraints(robot_model)\n\n        # Adjust parameters based on analysis\n        tuned_params = self.default_params.copy()\n\n        # For heavy robots, may need smaller time steps\n        if mass_distribution.max_mass > 50.0:  # kg\n            tuned_params['time_step'] = 0.0005\n            tuned_params['max_step_size'] = 0.0005\n\n        # For robots with many constraints, increase solver iterations\n        if joint_constraints.num_constraints > 20:\n            tuned_params['solver_iterations'] = 200\n\n        return tuned_params\n"})}),"\n",(0,o.jsx)(e.h2,{id:"advanced-gazebo-features",children:"Advanced Gazebo Features"}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-environments",children:"Dynamic Environments"}),"\n",(0,o.jsx)(e.p,{children:"Creating dynamic environments with moving objects:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Dynamic obstacle that moves in a pattern --\x3e\n<model name="moving_obstacle">\n  <link name="obstacle_link">\n    <pose>0 0 0.5 0 0 0</pose>\n    <inertial>\n      <mass>1.0</mass>\n      <inertia>\n        <ixx>0.01</ixx>\n        <ixy>0</ixy>\n        <ixz>0</ixz>\n        <iyy>0.01</iyy>\n        <iyz>0</iyz>\n        <izz>0.01</izz>\n      </inertia>\n    </inertial>\n    <collision name="collision">\n      <geometry>\n        <sphere>\n          <radius>0.2</radius>\n        </sphere>\n      </geometry>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <sphere>\n          <radius>0.2</radius>\n        </sphere>\n      </geometry>\n      <material>\n        <ambient>1 0 0 1</ambient>\n        <diffuse>1 0 0 1</diffuse>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Plugin to move the obstacle --\x3e\n  <gazebo>\n    <plugin name="moving_obstacle_plugin" filename="libMovingObstaclePlugin.so">\n      <linear_velocity>0.2</linear_velocity>\n      <angular_velocity>0.5</angular_velocity>\n      <motion_pattern>circular</motion_pattern>\n      <center_x>2.0</center_x>\n      <center_y>0.0</center_y>\n      <radius>1.0</radius>\n    </plugin>\n  </gazebo>\n</model>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"multi-robot-simulation",children:"Multi-Robot Simulation"}),"\n",(0,o.jsx)(e.p,{children:"Simulating multiple robots in the same environment:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- World with multiple robots --\x3e\n<?xml version="1.0"?>\n<sdf version="1.7">\n  <world name="multi_robot_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Robot 1 --\x3e\n    <include>\n      <uri>model://humanoid_robot</uri>\n      <name>robot1</name>\n      <pose>0 0 1.0 0 0 0</pose>\n    </include>\n\n    \x3c!-- Robot 2 --\x3e\n    <include>\n      <uri>model://humanoid_robot</uri>\n      <name>robot2</name>\n      <pose>2 0 1.0 0 0 0</pose>\n    </include>\n\n    \x3c!-- Robot 3 --\x3e\n    <include>\n      <uri>model://humanoid_robot</uri>\n      <name>robot3</name>\n      <pose>-2 0 1.0 0 0 0</pose>\n    </include>\n\n    \x3c!-- Common environment --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    <include>\n      <uri>model://sun</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"custom-plugins-for-specialized-behavior",children:"Custom Plugins for Specialized Behavior"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:"// Example: Custom plugin for humanoid balance simulation\n#include <gazebo/common/Plugin.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/sensors/sensors.hh>\n\nnamespace gazebo\n{\nclass HumanoidBalancePlugin : public ModelPlugin\n{\npublic:\n    void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf) override;\n    void OnUpdate();\n\nprivate:\n    physics::ModelPtr robot_model;\n    physics::PhysicsEnginePtr physics;\n    event::ConnectionPtr update_connection;\n\n    // Balance control components\n    std::vector<physics::JointPtr> leg_joints;\n    physics::LinkPtr torso_link;\n    physics::LinkPtr left_foot_link;\n    physics::LinkPtr right_foot_link;\n\n    // Balance controller parameters\n    double balance_gain = 50.0;\n    double zmp_tolerance = 0.05;\n\n    // ZMP calculation\n    ignition::math::Vector3d calculate_zmp();\n    void apply_balance_control(const ignition::math::Vector3d& zmp_error);\n};\n}\n"})}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-ros-2-ecosystem",children:"Integration with ROS 2 Ecosystem"}),"\n",(0,o.jsx)(e.h3,{id:"launch-files-for-complete-simulation",children:"Launch Files for Complete Simulation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# launch/humanoid_simulation.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler\nfrom launch.event_handlers import OnProcessExit\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Launch arguments\n    world_arg = DeclareLaunchArgument(\n        'world',\n        default_value='humanoid_world.sdf',\n        description='Choose one of the world files from `/gazebo_worlds`'\n    )\n\n    # Launch Gazebo\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            PathJoinSubstitution([\n                FindPackageShare('gazebo_ros'),\n                'launch',\n                'gazebo.launch.py'\n            ])\n        ]),\n        launch_arguments={\n            'world': LaunchConfiguration('world'),\n            'verbose': 'false'\n        }.items()\n    )\n\n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-topic', 'robot_description',\n            '-entity', 'humanoid_robot',\n            '-x', '0', '-y', '0', '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='screen',\n        parameters=[{\n            'robot_description': Command([\n                PathJoinSubstitution([FindPackageShare('my_robot_description'), 'urdf', 'robot.urdf']),\n                ' --param-name robot_description'\n            ])\n        }]\n    )\n\n    # Joint state broadcaster\n    joint_state_broadcaster_spawner = Node(\n        package='controller_manager',\n        executable='spawner',\n        arguments=['joint_state_broadcaster'],\n    )\n\n    # Robot controller\n    robot_controller_spawner = Node(\n        package='controller_manager',\n        executable='spawner',\n        arguments=['forward_position_controller'],\n    )\n\n    # Delay rviz start after joint_state_broadcaster spawner\n    delay_rviz_after_joint_state_broadcaster_spawner = RegisterEventHandler(\n        event_handler=OnProcessExit(\n            target_action=joint_state_broadcaster_spawner,\n            on_exit=[robot_controller_spawner],\n        )\n    )\n\n    return LaunchDescription([\n        world_arg,\n        gazebo,\n        spawn_entity,\n        robot_state_publisher,\n        joint_state_broadcaster_spawner,\n        delay_rviz_after_joint_state_broadcaster_spawner\n    ])\n"})}),"\n",(0,o.jsx)(e.h3,{id:"simulation-testing-framework",children:"Simulation Testing Framework"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# test/simulation_tester.py\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import PoseStamped\nimport numpy as np\nimport time\n\nclass SimulationTester(Node):\n    def __init__(self):\n        super().__init__('simulation_tester')\n\n        # Publishers for commands\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            '/joint_commands',\n            10\n        )\n\n        # Subscribers for feedback\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            10\n        )\n\n        # Test parameters\n        self.current_joint_states = JointState()\n        self.current_imu_data = Imu()\n        self.test_results = {}\n\n    def joint_state_callback(self, msg):\n        \"\"\"Store current joint states\"\"\"\n        self.current_joint_states = msg\n\n    def imu_callback(self, msg):\n        \"\"\"Store current IMU data\"\"\"\n        self.current_imu_data = msg\n\n    def test_balance_stability(self, duration=10.0):\n        \"\"\"Test robot balance stability\"\"\"\n        start_time = time.time()\n        stability_metrics = []\n\n        while time.time() - start_time < duration:\n            # Check IMU data for stability\n            roll = self.get_orientation_roll(self.current_imu_data.orientation)\n            pitch = self.get_orientation_pitch(self.current_imu_data.orientation)\n\n            # Calculate stability metric\n            stability = np.sqrt(roll**2 + pitch**2)\n            stability_metrics.append(stability)\n\n            time.sleep(0.1)\n\n        avg_stability = np.mean(stability_metrics)\n        max_stability = np.max(stability_metrics)\n\n        self.test_results['balance_stability'] = {\n            'avg_stability': avg_stability,\n            'max_stability': max_stability,\n            'pass': avg_stability < 0.1  # Less than 5.7 degrees average tilt\n        }\n\n        return self.test_results['balance_stability']\n\n    def test_joint_response(self, joint_index, target_position, settle_time=2.0):\n        \"\"\"Test joint response to position commands\"\"\"\n        # Send position command\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = [0.0] * len(self.current_joint_states.position)\n        cmd_msg.data[joint_index] = target_position\n\n        self.joint_cmd_pub.publish(cmd_msg)\n\n        # Wait for response\n        start_time = time.time()\n        initial_position = self.current_joint_states.position[joint_index]\n\n        while time.time() - start_time < settle_time:\n            current_pos = self.current_joint_states.position[joint_index]\n            error = abs(current_pos - target_position)\n\n            if error < 0.01:  # 0.01 rad tolerance\n                response_time = time.time() - start_time\n                self.test_results[f'joint_{joint_index}_response'] = {\n                    'response_time': response_time,\n                    'settling_error': error,\n                    'pass': response_time < 1.0\n                }\n                return self.test_results[f'joint_{joint_index}_response']\n\n            time.sleep(0.01)\n\n        # If didn't settle in time\n        final_error = abs(self.current_joint_states.position[joint_index] - target_position)\n        self.test_results[f'joint_{joint_index}_response'] = {\n            'response_time': settle_time,\n            'settling_error': final_error,\n            'pass': False\n        }\n\n        return self.test_results[f'joint_{joint_index}_response']\n\n    def run_comprehensive_test(self):\n        \"\"\"Run comprehensive simulation tests\"\"\"\n        results = {}\n\n        # Test 1: Balance stability\n        results['balance'] = self.test_balance_stability()\n\n        # Test 2: Joint responses\n        for i in range(min(5, len(self.current_joint_states.position))):\n            results[f'joint_{i}'] = self.test_joint_response(i, 0.5)\n\n        # Test 3: Walking pattern (if applicable)\n        results['walking'] = self.test_walking_pattern()\n\n        return results\n\n    def test_walking_pattern(self):\n        \"\"\"Test walking pattern in simulation\"\"\"\n        # Implement walking test\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    tester = SimulationTester()\n\n    # Run tests\n    results = tester.run_comprehensive_test()\n\n    # Print results\n    for test_name, result in results.items():\n        status = \"PASS\" if result.get('pass', False) else \"FAIL\"\n        print(f\"{test_name}: {status} - {result}\")\n\n    tester.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,o.jsx)(e.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:'# Check Gazebo performance\ngz stats\n\n# Monitor system resources\nhtop\nnvidia-smi  # If using GPU rendering\n\n# Adjust Gazebo parameters for better performance\nexport GAZEBO_MODEL_DATABASE_URI="http://models.gazebosim.org"\nexport GAZEBO_RESOURCE_PATH=$GAZEBO_RESOURCE_PATH:/path/to/custom/models\nexport GAZEBO_PLUGIN_PATH=$GAZEBO_PLUGIN_PATH:/path/to/custom/plugins\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-issues",children:"Physics Issues"}),"\n",(0,o.jsx)(e.p,{children:"Common physics-related problems and solutions:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Robot falling through ground:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check collision geometry"}),"\n",(0,o.jsx)(e.li,{children:"Verify mass and inertia parameters"}),"\n",(0,o.jsx)(e.li,{children:"Adjust contact parameters (kp, kd)"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Unstable joint behavior:"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce time step"}),"\n",(0,o.jsx)(e.li,{children:"Increase solver iterations"}),"\n",(0,o.jsx)(e.li,{children:"Check joint limits and dynamics"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Tunneling (objects passing through each other):"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Reduce time step"}),"\n",(0,o.jsx)(e.li,{children:"Increase update rate"}),"\n",(0,o.jsx)(e.li,{children:"Use continuous collision detection"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo provides a comprehensive physics-based simulation environment that is essential for Physical AI and humanoid robotics development. Its integration with ROS 2 enables seamless workflows from simulation to real-world deployment, while its flexible architecture supports custom plugins and complex multi-robot scenarios."}),"\n",(0,o.jsx)(e.p,{children:"The platform's realistic physics simulation, diverse sensor models, and extensive environment creation tools make it an invaluable tool for developing, testing, and validating humanoid robot behaviors before physical deployment. Proper configuration of physics parameters, sensor models, and control systems is crucial for achieving accurate sim-to-real transfer."}),"\n",(0,o.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Gazebo Documentation: ",(0,o.jsx)(e.a,{href:"http://gazebosim.org/",children:"http://gazebosim.org/"})]}),"\n",(0,o.jsxs)(e.li,{children:["ROS 2 Gazebo Integration: ",(0,o.jsx)(e.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"https://github.com/ros-simulation/gazebo_ros_pkgs"})]}),"\n",(0,o.jsx)(e.li,{children:'"Programming Robots with ROS" by Quigley et al.'}),"\n",(0,o.jsx)(e.li,{children:'"Robotics, Vision and Control" by Corke'}),"\n",(0,o.jsxs)(e.li,{children:["Gazebo Tutorials: ",(0,o.jsx)(e.a,{href:"http://gazebosim.org/tutorials",children:"http://gazebosim.org/tutorials"})]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>r});var o=i(6540);const t={},s=o.createContext(t);function a(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);