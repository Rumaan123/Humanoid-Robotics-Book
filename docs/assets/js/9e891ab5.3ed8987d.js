"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[209],{6249(n,e,i){i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=i(4848),o=i(8453);const s={sidebar_position:4},a="Physics Simulation Concepts: Rigid Body Dynamics and Collision Handling",l={id:"module-2/physics-simulation",title:"Physics Simulation Concepts: Rigid Body Dynamics and Collision Handling",description:"Overview",source:"@site/docs/module-2/physics-simulation.md",sourceDirName:"module-2",slug:"/module-2/physics-simulation",permalink:"/Humanoid-Robotics-Book/docs/module-2/physics-simulation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Purpose of Digital Twins in Physical AI: Simulation-Driven Robot Development",permalink:"/Humanoid-Robotics-Book/docs/module-2/purpose-of-digital-twins"},next:{title:"Environment and Robot Simulation using Gazebo: Physics-Based Digital Twins",permalink:"/Humanoid-Robotics-Book/docs/module-2/gazebo-simulation"}},r={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Fundamentals of Physics Simulation",id:"fundamentals-of-physics-simulation",level:2},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:3},{value:"Degrees of Freedom and Constraints",id:"degrees-of-freedom-and-constraints",level:3},{value:"Collision Detection",id:"collision-detection",level:2},{value:"Broad Phase Collision Detection",id:"broad-phase-collision-detection",level:3},{value:"Narrow Phase Collision Detection",id:"narrow-phase-collision-detection",level:3},{value:"Collision Response",id:"collision-response",level:2},{value:"Impulse-Based Collision Response",id:"impulse-based-collision-response",level:3},{value:"Multi-Body Dynamics",id:"multi-body-dynamics",level:2},{value:"Articulated Body Algorithm",id:"articulated-body-algorithm",level:3},{value:"Contact Dynamics for Multi-Body Systems",id:"contact-dynamics-for-multi-body-systems",level:3},{value:"Simulation Integration with ROS 2",id:"simulation-integration-with-ros-2",level:2},{value:"Physics Simulation Node",id:"physics-simulation-node",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Time Integration Methods",id:"time-integration-methods",level:3},{value:"Parallel Processing for Physics Simulation",id:"parallel-processing-for-physics-simulation",level:3},{value:"Physics Simulation Parameters and Tuning",id:"physics-simulation-parameters-and-tuning",level:2},{value:"Parameter Sensitivity Analysis",id:"parameter-sensitivity-analysis",level:3},{value:"Practical Applications in Humanoid Robotics",id:"practical-applications-in-humanoid-robotics",level:2},{value:"Balance and Stability Simulation",id:"balance-and-stability-simulation",level:3},{value:"Walking Simulation with Physics",id:"walking-simulation-with-physics",level:3},{value:"Best Practices for Physics Simulation",id:"best-practices-for-physics-simulation",level:2},{value:"Model Validation",id:"model-validation",level:3},{value:"Performance vs. Accuracy Trade-offs",id:"performance-vs-accuracy-trade-offs",level:3},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"physics-simulation-concepts-rigid-body-dynamics-and-collision-handling",children:"Physics Simulation Concepts: Rigid Body Dynamics and Collision Handling"}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Physics simulation forms the foundation of realistic digital twins in Physical AI, enabling accurate modeling of robot-environment interactions through the application of physical laws. In humanoid robotics, physics simulation must accurately represent complex phenomena including rigid body dynamics, collision detection and response, contact mechanics, and multi-body systems. Understanding these concepts is crucial for creating simulation environments that can effectively bridge the gap between virtual and real-world robot behavior."}),"\n",(0,t.jsx)(e.p,{children:"The accuracy of physics simulation directly impacts the effectiveness of sim-to-real transfer, where behaviors developed in simulation must translate successfully to physical robots. This requires careful attention to physical parameters, realistic modeling of forces and constraints, and proper handling of the complex interactions that occur in multi-degree-of-freedom systems like humanoid robots."}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this section, you should be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Explain fundamental physics simulation principles including rigid body dynamics"}),"\n",(0,t.jsx)(e.li,{children:"Understand collision detection and response mechanisms"}),"\n",(0,t.jsx)(e.li,{children:"Implement realistic physical properties for robot and environment models"}),"\n",(0,t.jsx)(e.li,{children:"Analyze the impact of simulation parameters on robot behavior"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"fundamentals-of-physics-simulation",children:"Fundamentals of Physics Simulation"}),"\n",(0,t.jsx)(e.h3,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,t.jsx)(e.p,{children:"Rigid body dynamics is the cornerstone of physics simulation in robotics, governing the motion of objects that maintain their shape under applied forces. In humanoid robotics, each link of the robot is typically modeled as a rigid body connected through joints."}),"\n",(0,t.jsx)(e.p,{children:"The motion of a rigid body is governed by Newton's laws of motion:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Linear Motion:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"F = ma\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Angular Motion:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"\u03c4 = I\u03b1\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"F is the applied force"}),"\n",(0,t.jsx)(e.li,{children:"m is the mass"}),"\n",(0,t.jsx)(e.li,{children:"a is the linear acceleration"}),"\n",(0,t.jsx)(e.li,{children:"\u03c4 is the applied torque"}),"\n",(0,t.jsx)(e.li,{children:"I is the moment of inertia"}),"\n",(0,t.jsx)(e.li,{children:"\u03b1 is the angular acceleration"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\nclass RigidBody:\n    def __init__(self, mass, inertia_tensor, position, orientation):\n        self.mass = mass\n        self.inertia_tensor = np.array(inertia_tensor)\n        self.position = np.array(position)\n        self.orientation = np.array(orientation)  # Quaternion\n        self.linear_velocity = np.zeros(3)\n        self.angular_velocity = np.zeros(3)\n\n    def update_dynamics(self, forces, torques, dt):\n        """Update rigid body state based on applied forces and torques"""\n        # Linear acceleration: a = F/m\n        linear_acceleration = np.array(forces) / self.mass\n\n        # Angular acceleration: \u03b1 = I^(-1) * \u03c4\n        # Need to account for rotating reference frame\n        inertia_inv = np.linalg.inv(self.inertia_tensor)\n        angular_acceleration = inertia_inv @ (np.array(torques) -\n                                            np.cross(self.angular_velocity,\n                                                   self.inertia_tensor @ self.angular_velocity))\n\n        # Update velocities\n        self.linear_velocity += linear_acceleration * dt\n        self.angular_velocity += angular_acceleration * dt\n\n        # Update positions\n        self.position += self.linear_velocity * dt\n        self.orientation += self.compute_orientation_derivative(\n            self.orientation, self.angular_velocity, dt\n        )\n\n    def compute_orientation_derivative(self, orientation, angular_velocity, dt):\n        """Compute orientation change from angular velocity"""\n        # Convert angular velocity to quaternion derivative\n        omega_quat = np.array([0, *angular_velocity])\n        quat_derivative = 0.5 * self.quaternion_multiply(orientation, omega_quat)\n        return quat_derivative * dt\n\n    def quaternion_multiply(self, q1, q2):\n        """Multiply two quaternions"""\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n\n        w = w1*w2 - x1*x2 - y1*y2 - z1*z2\n        x = w1*x2 + x1*w2 + y1*z2 - z1*y2\n        y = w1*y2 - x1*z2 + y1*w2 + z1*x2\n        z = w1*z2 + x1*y2 - y1*x2 + z1*w2\n\n        return np.array([w, x, y, z])\n'})}),"\n",(0,t.jsx)(e.h3,{id:"degrees-of-freedom-and-constraints",children:"Degrees of Freedom and Constraints"}),"\n",(0,t.jsx)(e.p,{children:"In physics simulation, constraints limit the motion of rigid bodies. For humanoid robots, joints impose specific constraints:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class JointConstraint:\n    def __init__(self, joint_type, parent_body, child_body):\n        self.joint_type = joint_type  # revolute, prismatic, fixed, etc.\n        self.parent = parent_body\n        self.child = child_body\n        self.constraint_matrix = self.compute_constraint_matrix()\n\n    def compute_constraint_matrix(self):\n        """Compute constraint matrix based on joint type"""\n        if self.joint_type == \'revolute\':\n            # 1 DOF rotation around axis\n            return np.array([\n                [1, 0, 0, 0, 0, 0],  # Constrain x translation\n                [0, 1, 0, 0, 0, 0],  # Constrain y translation\n                [0, 0, 1, 0, 0, 0],  # Constrain z translation\n                [0, 0, 0, 1, 0, 0],  # Constrain rotation around y\n                [0, 0, 0, 0, 1, 0],  # Constrain rotation around z\n            ])\n        elif self.joint_type == \'prismatic\':\n            # 1 DOF translation along axis\n            return np.array([\n                [0, 0, 0, 1, 0, 0],  # Constrain x rotation\n                [0, 0, 0, 0, 1, 0],  # Constrain y rotation\n                [0, 0, 0, 0, 0, 1],  # Constrain z rotation\n                [1, 0, 0, 0, 0, 0],  # Constrain y translation\n                [0, 1, 0, 0, 0, 0],  # Constrain z translation\n            ])\n        elif self.joint_type == \'fixed\':\n            # 0 DOF - fully constrained\n            return np.eye(6)\n\n    def apply_constraints(self, velocities):\n        """Apply constraints to reduce degrees of freedom"""\n        return self.constraint_matrix @ velocities\n'})}),"\n",(0,t.jsx)(e.h2,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,t.jsx)(e.h3,{id:"broad-phase-collision-detection",children:"Broad Phase Collision Detection"}),"\n",(0,t.jsx)(e.p,{children:"Collision detection typically uses a two-phase approach. The broad phase quickly eliminates pairs of objects that cannot possibly collide:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class BroadPhaseCollisionDetector:\n    def __init__(self):\n        self.spatial_grid = SpatialGrid(cell_size=1.0)\n        self.objects = []\n\n    def add_object(self, obj):\n        """Add object to collision detection system"""\n        self.objects.append(obj)\n        self.update_grid(obj)\n\n    def update_grid(self, obj):\n        """Update spatial grid with object bounds"""\n        grid_cells = self.get_grid_cells_for_object(obj)\n        for cell in grid_cells:\n            cell.add_object(obj)\n\n    def get_potential_collisions(self):\n        """Get pairs of objects that might collide"""\n        potential_pairs = set()\n\n        for cell in self.spatial_grid.get_occupied_cells():\n            objects_in_cell = cell.get_objects()\n            for i in range(len(objects_in_cell)):\n                for j in range(i + 1, len(objects_in_cell)):\n                    obj1, obj2 = objects_in_cell[i], objects_in_cell[j]\n                    potential_pairs.add((obj1, obj2))\n\n        return list(potential_pairs)\n\nclass SpatialGrid:\n    def __init__(self, cell_size):\n        self.cell_size = cell_size\n        self.grid = {}\n\n    def get_cell_key(self, position):\n        """Get grid cell key for position"""\n        x, y, z = position\n        return (int(x // self.cell_size),\n                int(y // self.cell_size),\n                int(z // self.cell_size))\n\n    def get_grid_cells_for_object(self, obj):\n        """Get all grid cells occupied by object"""\n        # Calculate bounding box\n        min_corner, max_corner = obj.get_bounding_box()\n\n        cells = []\n        start_key = self.get_cell_key(min_corner)\n        end_key = self.get_cell_key(max_corner)\n\n        for x in range(start_key[0], end_key[0] + 1):\n            for y in range(start_key[1], end_key[1] + 1):\n                for z in range(start_key[2], end_key[2] + 1):\n                    key = (x, y, z)\n                    if key not in self.grid:\n                        self.grid[key] = GridCell()\n                    cells.append(self.grid[key])\n\n        return cells\n'})}),"\n",(0,t.jsx)(e.h3,{id:"narrow-phase-collision-detection",children:"Narrow Phase Collision Detection"}),"\n",(0,t.jsx)(e.p,{children:"The narrow phase performs precise collision detection between potentially colliding pairs:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class NarrowPhaseCollisionDetector:\n    def __init__(self):\n        self.geometry_types = {\n            \'sphere\': self.sphere_collision,\n            \'box\': self.box_collision,\n            \'cylinder\': self.cylinder_collision,\n            \'mesh\': self.mesh_collision\n        }\n\n    def detect_collision(self, obj1, obj2):\n        """Detect collision between two objects"""\n        geom1_type = obj1.geometry_type\n        geom2_type = obj2.geometry_type\n\n        if (geom1_type, geom2_type) in self.geometry_types:\n            return self.geometry_types[(geom1_type, geom2_type)](obj1, obj2)\n        elif (geom2_type, geom1_type) in self.geometry_types:\n            # Check swapped order\n            result = self.geometry_types[(geom2_type, geom1_type)](obj2, obj1)\n            # Swap contact points if needed\n            if result:\n                result.swap_contacts()\n            return result\n        else:\n            return self.general_collision(obj1, obj2)\n\n    def sphere_collision(self, sphere1, sphere2):\n        """Detect collision between two spheres"""\n        center1 = sphere1.get_position()\n        center2 = sphere2.get_position()\n        distance = np.linalg.norm(center1 - center2)\n\n        if distance < (sphere1.radius + sphere2.radius):\n            # Collision detected\n            normal = (center2 - center1) / distance\n            penetration = (sphere1.radius + sphere2.radius) - distance\n\n            contact_point = center1 + normal * sphere1.radius\n            return CollisionResult(\n                contact_point=contact_point,\n                normal=normal,\n                penetration=penetration,\n                distance=distance\n            )\n        return None\n\n    def box_collision(self, box1, box2):\n        """Detect collision between two boxes using Separating Axis Theorem (SAT)"""\n        # Get all potential separating axes\n        axes = self.get_separating_axes(box1, box2)\n\n        for axis in axes:\n            proj1 = self.project_onto_axis(box1, axis)\n            proj2 = self.project_onto_axis(box2, axis)\n\n            if not self.projections_overlap(proj1, proj2):\n                return None  # No collision on this axis\n\n        # If all axes pass, there\'s a collision\n        # Find minimum penetration axis\n        min_penetration = float(\'inf\')\n        collision_normal = None\n\n        for axis in axes:\n            proj1 = self.project_onto_axis(box1, axis)\n            proj2 = self.project_onto_axis(box2, axis)\n            overlap = self.calculate_overlap(proj1, proj2)\n\n            if overlap < min_penetration:\n                min_penetration = overlap\n                collision_normal = axis\n\n        return CollisionResult(\n            contact_point=self.calculate_contact_point(box1, box2, collision_normal),\n            normal=collision_normal,\n            penetration=min_penetration\n        )\n\n    def get_separating_axes(self, box1, box2):\n        """Get potential separating axes for SAT"""\n        axes = []\n\n        # Face normals of box1\n        axes.extend(box1.get_face_normals())\n\n        # Face normals of box2\n        axes.extend(box2.get_face_normals())\n\n        # Edge cross products\n        for edge1 in box1.get_edge_directions():\n            for edge2 in box2.get_edge_directions():\n                cross = np.cross(edge1, edge2)\n                if np.linalg.norm(cross) > 1e-6:\n                    axes.append(cross / np.linalg.norm(cross))\n\n        return axes\n'})}),"\n",(0,t.jsx)(e.h2,{id:"collision-response",children:"Collision Response"}),"\n",(0,t.jsx)(e.h3,{id:"impulse-based-collision-response",children:"Impulse-Based Collision Response"}),"\n",(0,t.jsx)(e.p,{children:"Collision response determines how objects react when collisions are detected:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class CollisionResponse:\n    def __init__(self, restitution=0.3, friction=0.5):\n        self.restitution = restitution  # Coefficient of restitution\n        self.friction = friction        # Coefficient of friction\n\n    def resolve_collision(self, obj1, obj2, collision_result):\n        """Resolve collision between two objects"""\n        # Calculate relative velocity at contact point\n        r1 = collision_result.contact_point - obj1.position\n        r2 = collision_result.contact_point - obj2.position\n\n        v1 = obj1.linear_velocity + np.cross(obj1.angular_velocity, r1)\n        v2 = obj2.linear_velocity + np.cross(obj2.angular_velocity, r2)\n\n        relative_velocity = v1 - v2\n        normal_velocity = np.dot(relative_velocity, collision_result.normal)\n\n        # Separate objects to prevent sinking\n        self.separate_objects(obj1, obj2, collision_result)\n\n        # Only apply response if objects are approaching\n        if normal_velocity > 0:\n            return\n\n        # Calculate impulse magnitude\n        impulse_magnitude = self.calculate_impulse(\n            obj1, obj2, collision_result.normal, r1, r2, normal_velocity\n        )\n\n        # Apply impulse\n        impulse = impulse_magnitude * collision_result.normal\n        obj1.linear_velocity -= impulse / obj1.mass\n        obj2.linear_velocity += impulse / obj2.mass\n\n        # Apply angular impulse\n        obj1.angular_velocity -= obj1.inertia_tensor_inv @ np.cross(r1, impulse)\n        obj2.angular_velocity += obj2.inertia_tensor_inv @ np.cross(r2, impulse)\n\n        # Apply friction\n        self.apply_friction(obj1, obj2, collision_result, r1, r2)\n\n    def calculate_impulse(self, obj1, obj2, normal, r1, r2, normal_velocity):\n        """Calculate collision impulse magnitude"""\n        # Calculate inverse masses\n        inv_mass1 = 1.0 / obj1.mass\n        inv_mass2 = 1.0 / obj2.mass\n\n        # Calculate inverse moments of inertia\n        inv_inertia1 = obj1.inertia_tensor_inv\n        inv_inertia2 = obj2.inertia_tensor_inv\n\n        # Calculate effective mass\n        angular_factor1 = np.cross(r1, normal)\n        angular_factor1 = np.dot(inv_inertia1 @ angular_factor1, angular_factor1)\n\n        angular_factor2 = np.cross(r2, normal)\n        angular_factor2 = np.dot(inv_inertia2 @ angular_factor2, angular_factor2)\n\n        effective_mass = (inv_mass1 + inv_mass2 +\n                         angular_factor1 + angular_factor2)\n\n        # Calculate impulse with restitution\n        restitution_factor = -(1 + self.restitution) * normal_velocity\n        impulse = restitution_factor / effective_mass\n\n        return impulse\n\n    def apply_friction(self, obj1, obj2, collision_result, r1, r2):\n        """Apply friction forces"""\n        # Calculate tangential velocity\n        relative_velocity = (obj1.linear_velocity - obj2.linear_velocity +\n                           np.cross(obj1.angular_velocity, r1) -\n                           np.cross(obj2.angular_velocity, r2))\n\n        normal = collision_result.normal\n        tangential_velocity = relative_velocity - np.dot(relative_velocity, normal) * normal\n        tangential_speed = np.linalg.norm(tangential_velocity)\n\n        if tangential_speed < 1e-6:\n            return\n\n        # Calculate tangential direction\n        tangential_dir = tangential_velocity / tangential_speed\n\n        # Calculate friction impulse\n        impulse_magnitude = self.calculate_impulse(\n            obj1, obj2, tangential_dir, r1, r2, tangential_speed\n        )\n\n        # Apply friction with Coulomb\'s law (friction force limited by normal force)\n        max_friction_impulse = self.friction * abs(\n            np.dot(collision_result.normal,\n                  obj1.linear_velocity - obj2.linear_velocity)\n        )\n\n        friction_impulse = min(impulse_magnitude, max_friction_impulse)\n\n        # Apply friction impulse\n        friction_force = friction_impulse * tangential_dir\n        obj1.linear_velocity -= friction_force / obj1.mass\n        obj2.linear_velocity += friction_force / obj2.mass\n'})}),"\n",(0,t.jsx)(e.h2,{id:"multi-body-dynamics",children:"Multi-Body Dynamics"}),"\n",(0,t.jsx)(e.h3,{id:"articulated-body-algorithm",children:"Articulated Body Algorithm"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots with multiple interconnected bodies, specialized algorithms are needed:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class ArticulatedBody:\n    def __init__(self, links, joints):\n        self.links = links  # List of rigid bodies\n        self.joints = joints  # List of joint constraints\n        self.forward_kinematics = ForwardKinematicsSolver(links, joints)\n        self.inverse_dynamics = InverseDynamicsSolver(links, joints)\n\n    def compute_forward_dynamics(self, joint_positions, joint_velocities, joint_torques):\n        """Compute forward dynamics using articulated body algorithm"""\n        # Calculate accelerations from forces and torques\n        joint_accelerations = np.zeros(len(self.joints))\n\n        # Build system of equations using articulated body algorithm\n        # This is a simplified version - full implementation is more complex\n\n        # 1. Calculate bias forces (Coriolis, centrifugal, gravity)\n        bias_forces = self.calculate_bias_forces(\n            joint_positions, joint_velocities\n        )\n\n        # 2. Calculate mass matrix\n        mass_matrix = self.calculate_mass_matrix(joint_positions)\n\n        # 3. Solve for accelerations: M(q) * q_ddot + C(q, q_dot) = \u03c4\n        joint_accelerations = np.linalg.solve(\n            mass_matrix,\n            joint_torques - bias_forces\n        )\n\n        return joint_accelerations\n\n    def calculate_bias_forces(self, q, q_dot):\n        """Calculate Coriolis, centrifugal, and gravitational forces"""\n        # This would use the recursive Newton-Euler algorithm\n        # Simplified implementation\n        bias_forces = np.zeros(len(q))\n\n        # Gravity terms\n        gravity_forces = self.calculate_gravity_forces(q)\n\n        # Coriolis and centrifugal terms\n        coriolis_forces = self.calculate_coriolis_forces(q, q_dot)\n\n        bias_forces = gravity_forces + coriolis_forces\n\n        return bias_forces\n\n    def calculate_mass_matrix(self, q):\n        """Calculate the joint space mass matrix"""\n        # Use composite rigid body algorithm or other methods\n        n = len(q)\n        mass_matrix = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(n):\n                # Calculate mass matrix element\n                mass_matrix[i, j] = self.calculate_inertia_interaction(i, j, q)\n\n        return mass_matrix\n\n    def calculate_inertia_interaction(self, i, j, q):\n        """Calculate interaction between joints i and j"""\n        # This would involve complex geometric calculations\n        # Return the (i,j) element of the mass matrix\n        return 0.0  # Simplified\n'})}),"\n",(0,t.jsx)(e.h3,{id:"contact-dynamics-for-multi-body-systems",children:"Contact Dynamics for Multi-Body Systems"}),"\n",(0,t.jsx)(e.p,{children:"Handling contacts in multi-body systems requires solving constrained dynamics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class ContactDynamicsSolver:\n    def __init__(self):\n        self.constraint_solver = ConstraintSolver()\n\n    def solve_contact_dynamics(self, articulated_body, contact_constraints):\n        """Solve dynamics with contact constraints"""\n        # Formulate the constrained dynamics problem\n        # M(q) * q_ddot + C(q, q_dot) = \u03c4 + J^T * \u03bb\n        # where J is the constraint Jacobian and \u03bb are Lagrange multipliers\n\n        # Get system matrices\n        M = articulated_body.calculate_mass_matrix()\n        C = articulated_body.calculate_bias_forces()\n        tau = articulated_body.get_applied_torques()\n\n        # Get constraint information\n        J = self.build_constraint_jacobian(contact_constraints)\n        constraint_limits = self.get_constraint_limits(contact_constraints)\n\n        # Solve the linear complementarity problem (LCP)\n        accelerations, constraint_forces = self.solve_lcp(\n            M, C, tau, J, constraint_limits\n        )\n\n        return accelerations, constraint_forces\n\n    def solve_lcp(self, M, C, tau, J, limits):\n        """Solve Linear Complementarity Problem for contact forces"""\n        # The LCP formulation is:\n        # a = M^(-1) * (tau - C + J^T * lambda)\n        # 0 <= lambda \u22a5 a >= 0 (complementarity condition)\n\n        # This is a complex optimization problem\n        # Using projected Gauss-Seidel or similar iterative methods\n        max_iterations = 100\n        tolerance = 1e-6\n\n        lambda_ = np.zeros(J.shape[0])  # Constraint forces\n\n        for iteration in range(max_iterations):\n            # Update accelerations based on current constraint forces\n            accelerations = np.linalg.solve(M, tau - C + J.T @ lambda_)\n\n            # Calculate constraint accelerations\n            constraint_accel = J @ accelerations\n\n            # Update constraint forces using projected Gauss-Seidel\n            lambda_old = lambda_.copy()\n\n            for i in range(len(lambda_)):\n                # Calculate the effect of this constraint force on acceleration\n                J_row = J[i, :]\n                d = J_row @ np.linalg.solve(M, J_row.T)\n\n                if d > 1e-6:  # Avoid division by zero\n                    # Calculate required constraint force\n                    lambda_new = (limits[i] - constraint_accel[i]) / d + lambda_[i]\n\n                    # Apply limits (for inequality constraints)\n                    lambda_new = max(0, lambda_new)  # Non-penetration constraint\n\n                    # Update constraint force\n                    delta_lambda = lambda_new - lambda_[i]\n                    lambda_[i] = lambda_new\n\n                    # Update accelerations based on change in constraint force\n                    accelerations += np.linalg.solve(M, J_row.T * delta_lambda)\n                    constraint_accel = J @ accelerations\n\n            # Check for convergence\n            if np.linalg.norm(lambda_ - lambda_old) < tolerance:\n                break\n\n        return accelerations, lambda_\n'})}),"\n",(0,t.jsx)(e.h2,{id:"simulation-integration-with-ros-2",children:"Simulation Integration with ROS 2"}),"\n",(0,t.jsx)(e.h3,{id:"physics-simulation-node",children:"Physics Simulation Node"}),"\n",(0,t.jsx)(e.p,{children:"Integrating physics simulation with ROS 2:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import WrenchStamped\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass PhysicsSimulationNode(Node):\n    def __init__(self):\n        super().__init__(\'physics_simulation\')\n\n        # Publishers for simulation state\n        self.joint_state_pub = self.create_publisher(JointState, \'/joint_states\', 10)\n        self.imu_pub = self.create_publisher(Imu, \'/imu/data\', 10)\n        self.contact_pub = self.create_publisher(WrenchStamped, \'/contact_forces\', 10)\n\n        # Subscribers for commands\n        self.joint_cmd_sub = self.create_subscription(\n            Float64MultiArray,\n            \'/joint_commands\',\n            self.joint_command_callback,\n            10\n        )\n\n        # Physics simulation timer\n        self.physics_timer = self.create_timer(0.001, self.physics_step)  # 1kHz\n\n        # Initialize physics engine\n        self.physics_engine = PhysicsEngine()\n        self.robot_model = self.load_robot_model()\n        self.contact_manager = ContactManager()\n\n        # Initialize joint positions and velocities\n        self.joint_positions = np.zeros(len(self.robot_model.joints))\n        self.joint_velocities = np.zeros(len(self.robot_model.joints))\n        self.joint_commands = np.zeros(len(self.robot_model.joints))\n\n    def physics_step(self):\n        """Execute one physics simulation step"""\n        # Apply joint commands (torques or forces)\n        applied_torques = self.joint_commands.copy()\n\n        # Add gravity compensation if needed\n        gravity_compensation = self.calculate_gravity_compensation()\n        applied_torques += gravity_compensation\n\n        # Update physics simulation\n        joint_accelerations = self.physics_engine.compute_dynamics(\n            self.joint_positions,\n            self.joint_velocities,\n            applied_torques\n        )\n\n        # Integrate to get new positions and velocities\n        dt = 0.001  # 1kHz\n        self.joint_velocities += joint_accelerations * dt\n        self.joint_positions += self.joint_velocities * dt\n\n        # Handle contacts and collisions\n        contacts = self.contact_manager.detect_contacts(\n            self.robot_model,\n            self.joint_positions\n        )\n\n        # Publish simulation state\n        self.publish_joint_state()\n        self.publish_contact_forces(contacts)\n\n    def joint_command_callback(self, msg):\n        """Handle joint command messages"""\n        if len(msg.data) == len(self.joint_commands):\n            self.joint_commands = np.array(msg.data)\n        else:\n            self.get_logger().error(\n                f\'Command dimension mismatch: got {len(msg.data)}, expected {len(self.joint_commands)}\'\n            )\n\n    def calculate_gravity_compensation(self):\n        """Calculate gravity compensation torques"""\n        # Use inverse dynamics to calculate gravity effects\n        gravity_torques = self.physics_engine.calculate_gravity_torques(\n            self.joint_positions\n        )\n        return -gravity_torques\n\n    def publish_joint_state(self):\n        """Publish joint state information"""\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.name = [joint.name for joint in self.robot_model.joints]\n        msg.position = self.joint_positions.tolist()\n        msg.velocity = self.joint_velocities.tolist()\n\n        # Calculate effort from dynamics\n        effort = self.physics_engine.calculate_joint_efforts(\n            self.joint_positions,\n            self.joint_velocities,\n            self.joint_commands\n        )\n        msg.effort = effort.tolist()\n\n        self.joint_state_pub.publish(msg)\n\n    def publish_contact_forces(self, contacts):\n        """Publish contact force information"""\n        for contact in contacts:\n            msg = WrenchStamped()\n            msg.header.stamp = self.get_clock().now().to_msg()\n            msg.header.frame_id = contact.frame_id\n            msg.wrench.force.x = contact.force[0]\n            msg.wrench.force.y = contact.force[1]\n            msg.wrench.force.z = contact.force[2]\n            msg.wrench.torque.x = contact.torque[0]\n            msg.wrench.torque.y = contact.torque[1]\n            msg.wrench.torque.z = contact.torque[2]\n\n            self.contact_pub.publish(msg)\n'})}),"\n",(0,t.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(e.h3,{id:"time-integration-methods",children:"Time Integration Methods"}),"\n",(0,t.jsx)(e.p,{children:"Different integration methods affect both accuracy and performance:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class IntegrationMethods:\n    @staticmethod\n    def euler_integration(state, derivatives, dt):\n        """Simple Euler integration - fast but less accurate"""\n        return state + derivatives * dt\n\n    @staticmethod\n    def runge_kutta_4(state, derivatives_func, dt):\n        """4th-order Runge-Kutta - more accurate but slower"""\n        k1 = derivatives_func(state)\n        k2 = derivatives_func(state + 0.5 * dt * k1)\n        k3 = derivatives_func(state + 0.5 * dt * k2)\n        k4 = derivatives_func(state + dt * k3)\n\n        return state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n    @staticmethod\n    def verlet_integration(position, prev_position, acceleration, dt):\n        """Verlet integration - good for position-based constraints"""\n        new_position = 2 * position - prev_position + acceleration * dt**2\n        return new_position\n\n    @staticmethod\n    def semi_implicit_euler(position, velocity, acceleration, dt):\n        """Semi-implicit Euler - better stability than explicit"""\n        new_velocity = velocity + acceleration * dt\n        new_position = position + new_velocity * dt\n        return new_position, new_velocity\n'})}),"\n",(0,t.jsx)(e.h3,{id:"parallel-processing-for-physics-simulation",children:"Parallel Processing for Physics Simulation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import multiprocessing as mp\nfrom concurrent.futures import ProcessPoolExecutor\nimport numpy as np\n\nclass ParallelPhysicsSimulator:\n    def __init__(self, num_processes=None):\n        self.num_processes = num_processes or mp.cpu_count()\n        self.executor = ProcessPoolExecutor(max_workers=self.num_processes)\n\n    def parallel_collision_detection(self, objects):\n        """Perform collision detection in parallel"""\n        # Divide objects into chunks for parallel processing\n        chunk_size = max(1, len(objects) // self.num_processes)\n        object_chunks = [\n            objects[i:i + chunk_size]\n            for i in range(0, len(objects), chunk_size)\n        ]\n\n        # Process each chunk in parallel\n        futures = [\n            self.executor.submit(self.detect_collisions_in_chunk, chunk, objects)\n            for chunk in object_chunks\n        ]\n\n        # Collect results\n        all_collisions = []\n        for future in futures:\n            collisions = future.result()\n            all_collisions.extend(collisions)\n\n        return all_collisions\n\n    def detect_collisions_in_chunk(self, chunk, all_objects):\n        """Detect collisions for objects in a chunk"""\n        collisions = []\n\n        for obj1 in chunk:\n            for obj2 in all_objects:\n                if obj1 != obj2 and self.might_collide(obj1, obj2):\n                    collision = self.detect_precise_collision(obj1, obj2)\n                    if collision:\n                        collisions.append(collision)\n\n        return collisions\n'})}),"\n",(0,t.jsx)(e.h2,{id:"physics-simulation-parameters-and-tuning",children:"Physics Simulation Parameters and Tuning"}),"\n",(0,t.jsx)(e.h3,{id:"parameter-sensitivity-analysis",children:"Parameter Sensitivity Analysis"}),"\n",(0,t.jsx)(e.p,{children:"Understanding how physics parameters affect simulation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"class PhysicsParameterAnalyzer:\n    def __init__(self, simulation_model):\n        self.model = simulation_model\n        self.parameters = {\n            'gravity': 9.81,\n            'time_step': 0.001,\n            'restitution': 0.3,\n            'friction': 0.5,\n            'solver_iterations': 100\n        }\n\n    def analyze_parameter_sensitivity(self, parameter_name, range_values):\n        \"\"\"Analyze how parameter changes affect simulation behavior\"\"\"\n        results = []\n\n        for value in range_values:\n            # Set parameter\n            original_value = self.parameters[parameter_name]\n            self.parameters[parameter_name] = value\n\n            # Run simulation\n            behavior = self.run_parameterized_simulation()\n\n            # Record results\n            results.append({\n                'parameter_value': value,\n                'behavior_metrics': behavior,\n                'stability': self.check_stability(behavior),\n                'accuracy': self.check_accuracy(behavior)\n            })\n\n            # Restore original value\n            self.parameters[parameter_name] = original_value\n\n        return results\n\n    def run_parameterized_simulation(self):\n        \"\"\"Run simulation with current parameters\"\"\"\n        # This would run a specific test scenario\n        # and return measurable behavior metrics\n        pass\n\n    def recommend_parameters(self, desired_behavior):\n        \"\"\"Recommend physics parameters for desired behavior\"\"\"\n        # Use optimization techniques to find best parameters\n        # for achieving desired robot behavior\n        pass\n"})}),"\n",(0,t.jsx)(e.h2,{id:"practical-applications-in-humanoid-robotics",children:"Practical Applications in Humanoid Robotics"}),"\n",(0,t.jsx)(e.h3,{id:"balance-and-stability-simulation",children:"Balance and Stability Simulation"}),"\n",(0,t.jsx)(e.p,{children:"Physics simulation is crucial for humanoid balance:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class BalanceSimulation:\n    def __init__(self, humanoid_model):\n        self.humanoid = humanoid_model\n        self.physics = PhysicsEngine()\n        self.balance_controller = BalanceController()\n        self.zmp_calculator = ZeroMomentPointCalculator()\n\n    def simulate_balance_recovery(self, disturbance_force, duration):\n        """Simulate balance recovery from external disturbance"""\n        initial_state = self.humanoid.get_state()\n\n        # Apply disturbance\n        self.apply_disturbance(disturbance_force, duration)\n\n        # Simulate balance recovery\n        recovery_time = 0\n        max_time = 5.0  # 5 seconds to recover\n\n        while recovery_time < max_time:\n            # Calculate ZMP to check balance\n            zmp = self.zmp_calculator.calculate(self.humanoid.get_state())\n\n            # Check if balance is maintained\n            if self.is_balanced(zmp):\n                return recovery_time\n\n            # Apply balance control\n            control_torques = self.balance_controller.compute(\n                self.humanoid.get_state()\n            )\n\n            # Update physics simulation\n            self.physics.update(control_torques, 0.001)  # 1ms time step\n\n            recovery_time += 0.001\n\n        return -1  # Failed to recover balance\n\n    def is_balanced(self, zmp):\n        """Check if robot is in stable balance"""\n        support_polygon = self.calculate_support_polygon()\n        return self.is_point_in_polygon(zmp[:2], support_polygon)\n\n    def calculate_support_polygon(self):\n        """Calculate support polygon based on contact points"""\n        # Calculate polygon from feet contact points\n        # This would depend on robot\'s foot geometry\n        pass\n'})}),"\n",(0,t.jsx)(e.h3,{id:"walking-simulation-with-physics",children:"Walking Simulation with Physics"}),"\n",(0,t.jsx)(e.p,{children:"Simulating humanoid walking requires accurate physics:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class WalkingPhysicsSimulator:\n    def __init__(self, humanoid_model):\n        self.humanoid = humanoid_model\n        self.physics = PhysicsEngine()\n        self.gait_generator = GaitPatternGenerator()\n        self.footstep_planner = FootstepPlanner()\n\n    def simulate_walking_step(self, step_params):\n        """Simulate one walking step with full physics"""\n        # Generate gait pattern for step\n        trajectory = self.gait_generator.generate_step_trajectory(step_params)\n\n        # Simulate step execution\n        for t, state in enumerate(trajectory):\n            # Apply joint torques to follow trajectory\n            desired_torques = self.compute_trajectory_torques(state)\n\n            # Add balance control\n            balance_torques = self.compute_balance_torques()\n\n            # Total control torques\n            total_torques = desired_torques + balance_torques\n\n            # Update physics simulation\n            self.physics.update(total_torques, 0.001)\n\n            # Check for stability and contact transitions\n            if self.check_stability() and self.check_proper_contacts():\n                continue\n            else:\n                return False  # Step failed\n\n        return True  # Step successful\n'})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-for-physics-simulation",children:"Best Practices for Physics Simulation"}),"\n",(0,t.jsx)(e.h3,{id:"model-validation",children:"Model Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"class PhysicsModelValidator:\n    def __init__(self):\n        self.validation_tests = [\n            self.test_single_pendulum,\n            self.test_double_pendulum,\n            self.test_free_fall,\n            self.test_collision_bounce\n        ]\n\n    def validate_model(self, physics_model):\n        \"\"\"Validate physics model against known analytical solutions\"\"\"\n        results = {}\n\n        for test in self.validation_tests:\n            test_name = test.__name__\n            try:\n                error = test(physics_model)\n                results[test_name] = {'passed': error < 0.01, 'error': error}\n            except Exception as e:\n                results[test_name] = {'passed': False, 'error': float('inf'), 'exception': str(e)}\n\n        return results\n\n    def test_single_pendulum(self, model):\n        \"\"\"Test single pendulum motion against analytical solution\"\"\"\n        # Analytical period: T = 2\u03c0\u221a(L/g)\n        # Compare simulated vs analytical behavior\n        pass\n"})}),"\n",(0,t.jsx)(e.h3,{id:"performance-vs-accuracy-trade-offs",children:"Performance vs. Accuracy Trade-offs"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"class SimulationOptimizer:\n    def __init__(self):\n        self.accuracy_requirements = {\n            'kinematics': 0.001,  # 1mm accuracy\n            'dynamics': 0.01,     # 1% accuracy\n            'contacts': 0.005     # 5mm contact accuracy\n        }\n\n    def optimize_simulation(self, performance_target):\n        \"\"\"Optimize simulation parameters for performance target\"\"\"\n        # Start with high accuracy settings\n        params = {\n            'time_step': 0.001,\n            'solver_iterations': 200,\n            'contact_tolerance': 1e-6\n        }\n\n        # Gradually reduce accuracy while monitoring performance\n        while self.measure_performance() > performance_target:\n            # Increase time step (reduces accuracy)\n            params['time_step'] *= 1.1\n\n            # Reduce solver iterations\n            params['solver_iterations'] = max(10, int(params['solver_iterations'] * 0.9))\n\n            # Check if accuracy requirements are still met\n            if not self.check_accuracy_requirements(params):\n                # Backtrack if accuracy is compromised too much\n                params['time_step'] /= 1.1\n                params['solver_iterations'] = int(params['solver_iterations'] * 1.1 / 0.9)\n                break\n\n        return params\n"})}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Physics simulation is the backbone of realistic digital twins in Physical AI, enabling accurate modeling of robot-environment interactions. Understanding rigid body dynamics, collision detection and response, and multi-body systems is essential for creating simulation environments that can effectively support sim-to-real transfer. The choice of integration methods, collision algorithms, and physical parameters significantly impacts both the accuracy and performance of physics simulation."}),"\n",(0,t.jsx)(e.p,{children:"In humanoid robotics, physics simulation must handle complex multi-body dynamics with many degrees of freedom, making efficient algorithms and proper parameter tuning critical for realistic behavior. The integration with ROS 2 enables seamless workflows between simulation and real-world deployment, making physics simulation an indispensable tool for Physical AI development."}),"\n",(0,t.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:'"Rigid Body Dynamics Algorithms" by Featherstone'}),"\n",(0,t.jsx)(e.li,{children:'"Real-Time Rendering" by Akenine-M\xf6ller, Haines, and Hoffman'}),"\n",(0,t.jsx)(e.li,{children:'"Game Physics" by Eberly'}),"\n",(0,t.jsx)(e.li,{children:'"Physics-Based Animation" by Galoppo and McMillan'}),"\n",(0,t.jsx)(e.li,{children:"Open Dynamics Engine (ODE) Documentation"}),"\n",(0,t.jsx)(e.li,{children:"Bullet Physics Documentation"}),"\n",(0,t.jsxs)(e.li,{children:["ROS 2 Gazebo Integration: ",(0,t.jsx)(e.a,{href:"http://gazebosim.org/",children:"http://gazebosim.org/"})]}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>l});var t=i(6540);const o={},s=t.createContext(o);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);